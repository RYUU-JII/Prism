<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Prism Sandbox</title>
    <style id="prism-internal-styles">
      /* --- [1. 기본 레이아웃 스타일] --- */
      html, body {
        margin: 0; 
        padding: 0; 
        height: 100%; 
        min-height: 100%;
        background: transparent; 
        overflow: hidden;
        font-family: "Segoe UI", sans-serif; 
        color: #111;
      }

      /* 핵심 컨테이너 스타일 - 부모 창에서도 이 스타일이 적용되어야 합니다 */
      #prism-root {
        height: 100%; 
        min-height: 100vh;
        padding: 16px; 
        box-sizing: border-box;
        background: #ffffff; 
        overflow: hidden;
        position: relative;
      }

      #prism-root.mode-html {
        height: 100%; 
        min-height: 0; 
        padding: 0;
        background: transparent; 
        display: contents;
      }

      /* 유틸리티 및 에러 스타일 */
      .prism-empty { background: #f6f7fb; color: #5c6370; padding: 12px; border-radius: 10px; font-size: 12px; }
      .prism-error { background: #ffe9ea; color: #b30024; white-space: pre-wrap; padding: 12px; border-radius: 10px; font-size: 12px; }
      pre { background: #f4f4f4; padding: 1rem; border-radius: 8px; overflow: auto; }
      
      /* 다크모드 대응 */
      .dark #prism-root { background: #111; color: #fff; }
    </style>
  </head>
  <body>
    <div id="prism-root">
      <div class="prism-empty">Waiting for refraction...</div>
    </div>

    <script>
      /* --- [2. 자바스크립트 로직 시작] --- */
      document.documentElement.lang = navigator.language || "en";

      const root = document.getElementById("prism-root");
      const scriptCache = new Map();
      const libraryRegistry = new Map();
      const renderers = new Map();
      let activeReactRoot = null;
      const babelCache = new Map();
      const BABEL_CACHE_MAX = 12;
      const MAX_BABEL_CHARS = 120000;

      // 라이브러리 경로 정의
      const sources = {
        tailwind: "vendor/tailwindcss.js",
        babel: "vendor/babel.min.js",
        react: "vendor/react.production.min.js",
        reactDom: "vendor/react-dom.production.min.js",
        framerMotion: "vendor/framer-motion.js",
        html2canvas: "vendor/html2canvas.min.js"
      };

      // 라이브러리 동적 로더
      function loadScript(src) {
        if (scriptCache.has(src)) return scriptCache.get(src);
        const promise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = src; 
          script.async = false;
          script.onload = () => resolve();
          script.onerror = () => reject(new Error(`Failed to load ${src}`));
          document.head.appendChild(script);
        });
        scriptCache.set(src, promise);
        return promise;
      }

      async function loadLibraries(names) {
        const scripts = names.map(name => sources[name]).filter(Boolean);
        await Promise.all(scripts.map(src => loadScript(src)));
      }

      // --- [3. 코드 렌더링 핵심 로직] ---

      function stripImports(code) { return (code || "").replace(/^\s*import\s+[^;]+;?\s*$/gm, ""); }
      function normalizeExports(code) { return (code || "").replace(/^\s*export\s+default\s+/gm, "const PrismDefault = "); }
      function escapeHtml(value) { return (value || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); }
      function pickStyles(style, keys) {
        const out = {};
        keys.forEach((key) => {
          const value = style[key];
          if (value) out[key] = value;
        });
        return out;
      }
      function pickStyles(style, keys) {
        const out = {};
        keys.forEach((key) => {
          const value = style[key];
          if (value) out[key] = value;
        });
        return out;
      }

      // React 렌더러
      async function renderReact(code, theme) {
        try {
          if ((code || "").length > MAX_BABEL_CHARS) throw new Error("Code is too large.");
          
          await loadLibraries(["tailwind", "react", "reactDom", "babel"]);
          if (activeReactRoot) { activeReactRoot.unmount(); activeReactRoot = null; }
          
          root.innerHTML = "";
          root.className = "mode-app";
          if (theme === "dark") root.classList.add("dark");
          
          const mount = document.createElement("div");
          mount.id = "react-mount";
          root.appendChild(mount);

          const cleaned = normalizeExports(stripImports(code));
          const transformed = window.Babel.transform(cleaned, { presets: ["react"] }).code;
          
          const runner = `
            ${transformed}
            const Comp = typeof PrismDefault !== "undefined" ? PrismDefault : (typeof App !== "undefined" ? App : null);
            if(Comp) {
              const r = ReactDOM.createRoot(document.getElementById("react-mount"));
              r.render(React.createElement(Comp));
              window.__PRISM_ROOT__ = r;
            }
          `;
          new Function("React", "ReactDOM", runner)(window.React, window.ReactDOM);
          activeReactRoot = window.__PRISM_ROOT__;
        } catch (e) {
          root.innerHTML = `<div class="prism-error">${e.message}</div>`;
        }
      }

      // HTML 렌더러 (iframe 모드)
      async function renderHtml(code, theme) {
        if (activeReactRoot) { activeReactRoot.unmount(); activeReactRoot = null; }
        root.innerHTML = "";
        root.className = "mode-html";
        
        const frame = document.createElement("iframe");
        frame.setAttribute("sandbox", "allow-scripts allow-same-origin");
        frame.style.width = "100%";
        frame.style.height = "100%";
        frame.style.border = "0";
        
        // iframe 내부에서 스냅샷 요청을 처리할 수 있는 브릿지 삽입
        const snapshotBridge = `<script>
          window.addEventListener("message", function(event) {
            if (event.source !== parent || event.data?.type !== "PRISM_SNAPSHOT") return;
            try {
              const bodyStyle = window.getComputedStyle(document.body);
              const htmlStyle = window.getComputedStyle(document.documentElement);
              const keys = [
                "display","flexDirection","flexWrap","alignItems","justifyContent","alignContent",
                "gap","rowGap","columnGap","background","backgroundColor","color","padding","margin",
                "boxSizing","fontFamily","fontSize","lineHeight","letterSpacing"
              ];
              const pick = (style) => {
                const out = {};
                keys.forEach((k) => { if (style[k]) out[k] = style[k]; });
                return out;
              };

              parent.postMessage({
                type: "PRISM_EXPORT_FOR_CAPTURE",
                html: document.body.innerHTML,
                width: Math.max(document.body.scrollWidth, document.body.offsetWidth, 1),
                height: Math.max(document.body.scrollHeight, document.body.offsetHeight, 1),
                classes: document.documentElement.className + " " + document.body.className,
                bodyClass: document.body.className || "",
                bodyStyles: pick(bodyStyle),
                rootStyles: pick(bodyStyle),
                background: bodyStyle.backgroundColor || htmlStyle.backgroundColor || "#ffffff",
                color: bodyStyle.color || htmlStyle.color || "#111111",
                fontFamily: bodyStyle.fontFamily || htmlStyle.fontFamily || ""
              }, "*");
            } catch (e) { console.error(e); }
          });
        </` + "script>";
        
        frame.srcdoc = `<!DOCTYPE html><html class="${theme === "dark" ? "dark" : ""}">
          <head>
            <script src="vendor/tailwindcss.js"><\/script>
            ${snapshotBridge}
          </head>
          <body>${code}</body></html>`;
        root.appendChild(frame);
      }

      // --- [4. 캡처 데이터 추출 및 전송 로직] ---

        
      // sandbox.html 내 captureSnapshot 함수 수정
      function captureSnapshot() {
        console.group("[Prism Sandbox] 캡처 데이터 추출 시작");
        const frame = root.querySelector("iframe");
        
        if (frame?.contentWindow) {
          console.log("-> Iframe 모드 감지");
          frame.contentWindow.postMessage({ type: "PRISM_SNAPSHOT" }, "*");
          console.groupEnd();
          return;
        }

        try {
          const rootStyle = window.getComputedStyle(root);
          const bodyStyle = window.getComputedStyle(document.body);
          const docStyle = window.getComputedStyle(document.documentElement);
          const keys = [
            "display",
            "flexDirection",
            "flexWrap",
            "alignItems",
            "justifyContent",
            "alignContent",
            "gap",
            "rowGap",
            "columnGap",
            "background",
            "backgroundColor",
            "color",
            "padding",
            "paddingTop",
            "paddingRight",
            "paddingBottom",
            "paddingLeft",
            "margin",
            "marginTop",
            "marginRight",
            "marginBottom",
            "marginLeft",
            "boxSizing",
            "fontFamily",
            "fontSize",
            "lineHeight",
            "letterSpacing"
          ];
          const width = Math.max(root.scrollWidth, root.offsetWidth, 1);
          const height = Math.max(root.scrollHeight, root.offsetHeight, 1);
          const payload = {
            type: "PRISM_EXPORT_FOR_CAPTURE",
            html: root.innerHTML,
            width,
            height,
            classes: document.documentElement.className + " " + root.className,
            bodyClass: document.body.className || "",
            bodyStyles: pickStyles(bodyStyle, keys),
            rootStyles: pickStyles(rootStyle, keys),
            background:
              rootStyle.backgroundColor ||
              bodyStyle.backgroundColor ||
              docStyle.backgroundColor ||
              "#ffffff",
            color: rootStyle.color || bodyStyle.color || docStyle.color || "#111111",
            fontFamily: rootStyle.fontFamily || bodyStyle.fontFamily || docStyle.fontFamily || ""
          };

          console.log("-> 추출 완료. 페이로드:", {
            htmlLength: payload.html.length,
            dims: `${payload.width}x${payload.height}`,
            bg: payload.background
          });

          window.parent.postMessage(payload, "*");
          console.groupEnd();
        } catch (error) {
          console.error("[Prism Sandbox] 추출 실패:", error);
          console.groupEnd();
        }
      }

      // --- [5. 메시지 리스너 및 초기화] ---

      window.addEventListener("message", (event) => {
        const data = event.data || {};
        const iframeWindow = root.querySelector("iframe")?.contentWindow;
        
        // iframe 내부에서 올라온 캡처 데이터를 부모 창으로 전달
        if (data.type === "PRISM_EXPORT_FOR_CAPTURE" && event.source === iframeWindow) {
          window.parent.postMessage(data, "*");
          return;
        }
        
        if (event.source !== window.parent) return;
        
        if (data.type === "RENDER") {
          const kind = data.language === "html" ? "html" : (data.language === "react" ? "react" : "text");
          if (kind === "react") renderReact(data.code, data.theme);
          else if (kind === "html") renderHtml(data.code, data.theme);
          else {
            root.className = "mode-text";
            root.innerHTML = `<pre>${escapeHtml(data.code)}</pre>`;
          }
        }
        
        if (data.type === "PRISM_SNAPSHOT") {
          captureSnapshot();
        }
      });
    </script>
  </body>
</html>
