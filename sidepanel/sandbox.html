<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Prism Sandbox</title>
    <style id="prism-internal-styles">
      /* --- [1. 기본 레이아웃 스타일] --- */
      html, body {
        margin: 0; 
        padding: 0; 
        height: 100%; 
        min-height: 100%;
        background: transparent; 
        overflow: hidden;
        font-family: "Segoe UI", sans-serif; 
        color: #111;
      }

      /* 핵심 컨테이너 스타일 - 부모 창에서도 이 스타일이 적용되어야 합니다 */
      #prism-root {
        height: 100%; 
        min-height: 100vh;
        padding: 16px; 
        box-sizing: border-box;
        background: #ffffff; 
        overflow: hidden;
        position: relative;
      }

      #prism-root.mode-html {
        height: 100%; 
        min-height: 0; 
        padding: 0;
        background: transparent; 
        display: contents;
      }

      /* 유틸리티 및 에러 스타일 */
      .prism-empty { background: #f6f7fb; color: #5c6370; padding: 12px; border-radius: 10px; font-size: 12px; }
      .prism-error { background: #ffe9ea; color: #b30024; white-space: pre-wrap; padding: 12px; border-radius: 10px; font-size: 12px; }
      pre { background: #f4f4f4; padding: 1rem; border-radius: 8px; overflow: auto; }
      
      /* 다크모드 대응 */
      .dark #prism-root { background: #111; color: #fff; }
    </style>
    <link rel="stylesheet" href="tailwind.css" />
  </head>
  <body>
    <div id="prism-root">
      <div class="prism-empty">Waiting for refraction...</div>
    </div>

    <script>
      /* --- [2. 자바스크립트 로직 시작] --- */
      document.documentElement.lang = navigator.language || "en";

      const root = document.getElementById("prism-root");
      const scriptCache = new Map();
      const libraryRegistry = new Map();
      const renderers = new Map();
      let activeReactRoot = null;
      let pickerActive = false;
      const babelCache = new Map();
      const BABEL_CACHE_MAX = 12;
      const MAX_BABEL_CHARS = 120000;

      // 라이브러리 경로 정의
      const sources = {
        babel: "vendor/babel.min.js",
        react: "vendor/react.production.min.js",
        reactDom: "vendor/react-dom.production.min.js",
        framerMotion: "vendor/framer-motion.js",
        html2canvas: "vendor/html2canvas.min.js"
      };

      // 라이브러리 동적 로더
      function loadScript(src) {
        if (scriptCache.has(src)) return scriptCache.get(src);
        const promise = new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = src; 
          script.async = false;
          script.onload = () => resolve();
          script.onerror = () => reject(new Error(`Failed to load ${src}`));
          document.head.appendChild(script);
        });
        scriptCache.set(src, promise);
        return promise;
      }

      async function loadLibraries(names) {
        const scripts = names.map(name => sources[name]).filter(Boolean);
        await Promise.all(scripts.map(src => loadScript(src)));
      }

      // --- [3. 코드 렌더링 핵심 로직] ---

      function stripImports(code) { return (code || "").replace(/^\s*import\s+[^;]+;?\s*$/gm, ""); }
      function normalizeExports(code) { return (code || "").replace(/^\s*export\s+default\s+/gm, "const PrismDefault = "); }
      function escapeHtml(value) { return (value || "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); }
      function pickStyles(style, keys) {
        const out = {};
        keys.forEach((key) => {
          const value = style[key];
          if (value) out[key] = value;
        });
        return out;
      }

      // React 렌더러
      async function renderReact(code, theme) {
        try {
          if ((code || "").length > MAX_BABEL_CHARS) throw new Error("Code is too large.");
          
          await loadLibraries(["react", "reactDom", "babel"]);
          if (activeReactRoot) { activeReactRoot.unmount(); activeReactRoot = null; }
          
          root.innerHTML = "";
          root.className = "mode-app";
          if (theme === "dark") root.classList.add("dark");
          
          const mount = document.createElement("div");
          mount.id = "react-mount";
          root.appendChild(mount);

          const cleaned = normalizeExports(stripImports(code));
          const transformed = window.Babel.transform(cleaned, { presets: ["react"] }).code;
          
          const runner = `
            ${transformed}
            const Comp = typeof PrismDefault !== "undefined" ? PrismDefault : (typeof App !== "undefined" ? App : null);
            if(Comp) {
              const r = ReactDOM.createRoot(document.getElementById("react-mount"));
              r.render(React.createElement(Comp));
              window.__PRISM_ROOT__ = r;
            }
          `;
          new Function("React", "ReactDOM", runner)(window.React, window.ReactDOM);
          activeReactRoot = window.__PRISM_ROOT__;
        } catch (e) {
          root.innerHTML = `<div class="prism-error">${e.message}</div>`;
        }
      }

      // HTML 렌더러 (iframe 모드)
      async function renderHtml(code, theme) {
        if (activeReactRoot) { activeReactRoot.unmount(); activeReactRoot = null; }
        root.innerHTML = "";
        root.className = "mode-html";
        
        const frame = document.createElement("iframe");
        frame.setAttribute("sandbox", "allow-scripts allow-same-origin");
        frame.style.width = "100%";
        frame.style.height = "100%";
        frame.style.border = "0";
        
        // [수정됨] iframe 내부 브릿지: 데스크톱 너비(1280px) 전송
        const snapshotBridge = `<script>
          window.addEventListener("message", function(event) {
            if (event.source !== parent || !event.data || event.data.type !== "PRISM_SNAPSHOT") return;
            try {
              const bodyStyle = window.getComputedStyle(document.body);
              const htmlStyle = window.getComputedStyle(document.documentElement);
              const keys = [
                "display","flexDirection","flexWrap","alignItems","justifyContent","alignContent",
                "gap","rowGap","columnGap","background","backgroundColor","color","padding","margin",
                "boxSizing","fontFamily","fontSize","lineHeight","letterSpacing"
              ];
              const pick = (style) => {
                const out = {};
                keys.forEach((k) => { if (style[k]) out[k] = style[k]; });
                return out;
              };

              // 데스크톱 캡처를 위한 강제 너비 설정
              const VIRTUAL_WIDTH = 1280;

              parent.postMessage({
                type: "PRISM_EXPORT_FOR_CAPTURE",
                html: document.body.innerHTML,
                width: VIRTUAL_WIDTH,
                height: Math.max(document.body.scrollHeight, document.body.offsetHeight, 1),
                classes: document.documentElement.className + " " + document.body.className,
                bodyClass: document.body.className || "",
                bodyStyles: pick(bodyStyle),
                rootStyles: pick(bodyStyle),
                background: bodyStyle.backgroundColor || htmlStyle.backgroundColor || "#ffffff",
                color: bodyStyle.color || htmlStyle.color || "#111111",
                fontFamily: bodyStyle.fontFamily || htmlStyle.fontFamily || ""
              }, "*");
            } catch (e) { console.error(e); }
          });

          // 키보드 포커스가 iframe 안으로 들어가면 부모(sandbox)에서 keydown을 못 받으므로,
          // iframe에서 직접 잡아서 parent로 전달합니다.
          window.addEventListener("keydown", function(event) {
            if (event.altKey && event.key === "ArrowLeft") {
              try {
                event.preventDefault();
                event.stopPropagation();
              } catch (e) {}
              parent.postMessage({ type: "PRISM_RETURN_REQUEST" }, "*");
            }
          });

          let prismPickerActive = false;
          let prismPickerOverlay = null;
          let prismPickerTarget = null;
          let prismMotionStyle = null;

          function setMotionFreeze(active) {
            if (active) {
              if (prismMotionStyle) return;
              const style = document.createElement("style");
              style.id = "prism-picker-freeze";
              style.textContent = [
                "html, body { scroll-behavior: auto !important; }",
                "*, *::before, *::after {",
                "  animation-play-state: paused !important;",
                "  transition: none !important;",
                "}"
              ].join("\\n");
              document.head.appendChild(style);
              prismMotionStyle = style;
              return;
            }
            if (prismMotionStyle) {
              prismMotionStyle.remove();
              prismMotionStyle = null;
            }
          }

          function ensurePickerOverlay() {
            if (prismPickerOverlay) return prismPickerOverlay;
            const overlay = document.createElement("div");
            overlay.style.position = "fixed";
            overlay.style.zIndex = "2147483647";
            overlay.style.pointerEvents = "none";
            overlay.style.border = "2px solid rgba(79, 210, 195, 0.9)";
            overlay.style.background = "rgba(79, 210, 195, 0.12)";
            overlay.style.boxShadow = "0 0 0 1px rgba(0, 0, 0, 0.2)";
            overlay.style.borderRadius = "6px";
            document.documentElement.appendChild(overlay);
            prismPickerOverlay = overlay;
            return overlay;
          }

          function updatePickerOverlay(target) {
            if (!target || !target.getBoundingClientRect) return;
            const rect = target.getBoundingClientRect();
            if (!rect.width && !rect.height) return;
            const overlay = ensurePickerOverlay();
            overlay.style.left = rect.left + "px";
            overlay.style.top = rect.top + "px";
            overlay.style.width = rect.width + "px";
            overlay.style.height = rect.height + "px";
          }

          function clearPickerOverlay() {
            if (!prismPickerOverlay) return;
            prismPickerOverlay.remove();
            prismPickerOverlay = null;
            prismPickerTarget = null;
          }

          function setPickerActive(active) {
            prismPickerActive = Boolean(active);
            document.body.style.cursor = prismPickerActive ? "crosshair" : "";
            setMotionFreeze(prismPickerActive);
            if (!prismPickerActive) {
              clearPickerOverlay();
            }
          }

          function pickTarget(rawTarget) {
            if (!(rawTarget instanceof Element)) return null;
            return rawTarget.closest("[data-prism-line]") || rawTarget;
          }

          document.addEventListener("mousemove", function(event) {
            if (!prismPickerActive) return;
            const target = pickTarget(event.target);
            if (!target || target === document.documentElement || target === document.body) return;
            prismPickerTarget = target;
            updatePickerOverlay(target);
          }, true);

          document.addEventListener("click", function(event) {
            if (!prismPickerActive) return;
            try {
              event.preventDefault();
              event.stopPropagation();
              event.stopImmediatePropagation();
            } catch (e) {}
            const target = pickTarget(event.target);
            if (!target) return;
            const line = Number(target.getAttribute("data-prism-line")) || 1;
            parent.postMessage({ type: "PRISM_PICKER_SELECT", line }, "*");
          }, true);

          document.addEventListener("scroll", function() {
            if (!prismPickerActive || !prismPickerTarget) return;
            updatePickerOverlay(prismPickerTarget);
          }, true);

          window.addEventListener("message", function(event) {
            if (!event.data || event.data.type !== "PRISM_PICKER_TOGGLE") return;
            try {
              parent.postMessage({
                type: "PRISM_DEVLOG",
                stage: "picker-toggle-received",
                payload: { active: Boolean(event.data.active) }
              }, "*");
            } catch (e) {}
            setPickerActive(Boolean(event.data.active));
          });

          try {
            parent.postMessage({
              type: "PRISM_DEVLOG",
              stage: "picker-bridge-loaded",
              payload: { ok: true }
            }, "*");
          } catch (e) {}
        </` + "script>";
        
        frame.srcdoc = `<!DOCTYPE html><html class="${theme === "dark" ? "dark" : ""}">
          <head>
            <link rel="stylesheet" href="tailwind.css" />
            ${snapshotBridge}
          </head>
          <body>${code}</body></html>`;
        root.appendChild(frame);
        frame.addEventListener("load", () => {
          if (pickerActive && frame.contentWindow) {
            frame.contentWindow.postMessage({ type: "PRISM_PICKER_TOGGLE", active: true }, "*");
          }
        });
      }

      // --- [4. 캡처 데이터 추출 및 전송 로직] ---

      // [수정됨] 메인 캡처 함수: 데스크톱 너비(1280px) 전송
      function captureSnapshot() {
        const frame = root.querySelector("iframe");
        
        if (frame?.contentWindow) {
          frame.contentWindow.postMessage({ type: "PRISM_SNAPSHOT" }, "*");
          return;
        }

        try {
          const rootStyle = window.getComputedStyle(root);
          const bodyStyle = window.getComputedStyle(document.body);
          const docStyle = window.getComputedStyle(document.documentElement);
          const keys = [
            "display",
            "flexDirection",
            "flexWrap",
            "alignItems",
            "justifyContent",
            "alignContent",
            "gap",
            "rowGap",
            "columnGap",
            "background",
            "backgroundColor",
            "color",
            "padding",
            "paddingTop",
            "paddingRight",
            "paddingBottom",
            "paddingLeft",
            "margin",
            "marginTop",
            "marginRight",
            "marginBottom",
            "marginLeft",
            "boxSizing",
            "fontFamily",
            "fontSize",
            "lineHeight",
            "letterSpacing"
          ];

          // 데스크톱 캡처를 위한 강제 너비 설정
          const VIRTUAL_WIDTH = 1280;
          const height = Math.max(root.scrollHeight, root.offsetHeight, 1);

          const payload = {
            type: "PRISM_EXPORT_FOR_CAPTURE",
            html: root.innerHTML,
            width: VIRTUAL_WIDTH,
            height,
            classes: document.documentElement.className + " " + root.className,
            bodyClass: document.body.className || "",
            bodyStyles: pickStyles(bodyStyle, keys),
            rootStyles: pickStyles(rootStyle, keys),
            background:
              rootStyle.backgroundColor ||
              bodyStyle.backgroundColor ||
              docStyle.backgroundColor ||
              "#ffffff",
            color: rootStyle.color || bodyStyle.color || docStyle.color || "#111111",
            fontFamily: rootStyle.fontFamily || bodyStyle.fontFamily || docStyle.fontFamily || ""
          };

          window.parent.postMessage(payload, "*");
        } catch (error) {
          console.error("[Prism Sandbox] 추출 실패:", error);
        }
      }

      // --- [5. 메시지 리스너 및 초기화] ---

      window.addEventListener("message", (event) => {
        const data = event.data || {};
        const iframeWindow = root.querySelector("iframe")?.contentWindow;
        
        // iframe 내부에서 올라온 캡처 데이터를 부모 창으로 전달
        if (data.type === "PRISM_EXPORT_FOR_CAPTURE" && event.source === iframeWindow) {
          window.parent.postMessage(data, "*");
          return;
        }

        if (data.type === "PRISM_DEVLOG" && event.source === iframeWindow) {
          window.parent.postMessage(data, "*");
          return;
        }

        if (data.type === "PRISM_PICKER_SELECT" && event.source === iframeWindow) {
          window.parent.postMessage(data, "*");
          return;
        }

        // iframe 내부(HTML srcdoc)에서 온 "돌아가기" 요청을 부모로 전달
        if (data.type === "PRISM_RETURN_REQUEST" && event.source === iframeWindow) {
          window.parent.postMessage({ type: "PRISM_RETURN_REQUEST" }, "*");
          return;
        }
        
        if (data.type === "PRISM_PICKER_TOGGLE") {
          pickerActive = Boolean(data.active);
          if (iframeWindow) {
            iframeWindow.postMessage({ type: "PRISM_PICKER_TOGGLE", active: pickerActive }, "*");
          }
          window.parent.postMessage({
            type: "PRISM_DEVLOG",
            stage: "picker-toggle-forwarded",
            payload: { active: pickerActive, hasIframe: Boolean(iframeWindow) }
          }, "*");
          return;
        }

        if (event.source !== window.parent) return;

        if (data.type === "RENDER") {
          const kind = data.language === "html" ? "html" : (data.language === "react" ? "react" : "text");
          if (kind === "react") renderReact(data.code, data.theme);
          else if (kind === "html") renderHtml(data.code, data.theme);
          else {
            root.className = "mode-text";
            root.innerHTML = `<pre>${escapeHtml(data.code)}</pre>`;
          }
        }
        
        if (data.type === "PRISM_SNAPSHOT") {
          captureSnapshot();
        }
      });

      window.addEventListener("keydown", (event) => {
        if (event.altKey && event.key === "ArrowLeft") {
          window.parent.postMessage({ type: "PRISM_RETURN_REQUEST" }, "*");
        }
      });

      function sendDebugLog(stage, payload) {
        window.parent.postMessage(
          {
            type: "PRISM_DEVLOG",
            stage,
            payload
          },
          "*"
        );
      }

      window.addEventListener("pointerdown", (event) => {
        sendDebugLog("pointerdown", {
          button: event.button,
          buttons: event.buttons,
          pointerType: event.pointerType
        });
      });

      window.addEventListener("mouseup", (event) => {
        sendDebugLog("mouseup", {
          button: event.button,
          buttons: event.buttons
        });
      });
    </script>
  </body>
</html>
