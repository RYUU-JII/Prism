document.documentElement.lang = navigator.language || "en";

const viewer = document.getElementById("viewer");
const snapshotBtn = document.getElementById("snapshot-btn");
const copyBtn = document.getElementById("copy-btn");
const saveHtmlBtn = document.getElementById("save-html-btn");
const openWindowBtn = document.getElementById("open-window-btn");
const panelShell = document.querySelector(".panel-shell");

let pendingPayload = null;
let viewerReady = false;
let latestPayload = null;
let pendingSnapshotAction = null;
let currentTabId = null;

const urlParams = new URLSearchParams(window.location.search);
const targetTabId = urlParams.get("tabId");

const scriptLoadCache = new Map();
const styleLoadCache = new Map();

function loadScriptOnce(src, globalName) {
  if (globalName && window[globalName]) return Promise.resolve();
  if (scriptLoadCache.has(src)) return scriptLoadCache.get(src);
  const promise = new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = chrome.runtime.getURL(src);
    script.async = true;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Failed to load ${src}`));
    document.head.appendChild(script);
  });
  scriptLoadCache.set(src, promise);
  return promise;
}

function loadStyleOnce(href) {
  if (styleLoadCache.has(href)) return styleLoadCache.get(href);
  const existing = document.querySelector(`link[data-prism-style="${href}"]`);
  if (existing) return Promise.resolve();
  const promise = new Promise((resolve, reject) => {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.href = chrome.runtime.getURL(href);
    link.dataset.prismStyle = href;
    link.onload = () => resolve();
    link.onerror = () => reject(new Error(`Failed to load ${href}`));
    document.head.appendChild(link);
  });
  styleLoadCache.set(href, promise);
  return promise;
}

function applyInlineStyles(element, styles) {
  if (!element || !styles) return;
  Object.keys(styles).forEach((key) => {
    element.style[key] = styles[key];
  });
}

function waitForPaint(frames = 2) {
  return new Promise((resolve) => {
    let count = 0;
    const tick = () => {
      count += 1;
      if (count >= frames) {
        resolve();
      } else {
        requestAnimationFrame(tick);
      }
    };
    requestAnimationFrame(tick);
  });
}

/**
 * 부모 컨텍스트에서 캡처를 수행합니다.
 * 레이아웃 동기화, 스타일 주입, 렌더 대기, 배경 보정까지 처리합니다.
 */
async function performCaptureInParent(data) {
  console.info("[Prism] Parent capture requested.", {
    width: data?.width,
    height: data?.height,
    classes: data?.classes
  });
  const action = pendingSnapshotAction || "download";
  pendingSnapshotAction = null;

  let container = null;
  let stage = null;
  try {
    if (!data || !data.html) {
      throw new Error("No capture payload provided.");
    }

    const width = Math.max(1, Math.ceil(Number(data.width) || 0));
    const height = Math.max(1, Math.ceil(Number(data.height) || 0));

    container = document.createElement("div");
    container.id = "prism-capture-root";
    container.className = (data.bodyClass || "").trim();
    container.style.position = "fixed";
    container.style.left = "-9999px";
    container.style.top = "0";
    container.style.width = `${width}px`;
    container.style.height = `${height}px`;
    container.style.zIndex = "-1";
    container.style.pointerEvents = "none";
    container.style.boxSizing = "border-box";
    container.style.contain = "layout paint";
    container.style.overflow = "hidden";
    applyInlineStyles(container, data.bodyStyles);
    container.style.background = data.background || container.style.background || "#ffffff";
    container.style.color = data.color || container.style.color || "#111111";
    container.style.fontFamily = data.fontFamily || container.style.fontFamily || "inherit";

    stage = document.createElement("div");
    stage.id = "prism-root";
    stage.className = (data.classes || "").trim();
    stage.style.width = `${width}px`;
    stage.style.height = `${height}px`;
    stage.style.position = "relative";
    stage.style.boxSizing = "border-box";
    applyInlineStyles(stage, data.rootStyles);
    stage.innerHTML = data.html;

    stage.querySelectorAll("script").forEach((el) => el.remove());
    stage.querySelectorAll("link[rel='stylesheet']").forEach((el) => el.remove());
    stage.querySelectorAll("iframe, frame, object, embed").forEach((el) => {
      const placeholder = document.createElement("div");
      const rect = el.getBoundingClientRect();
      placeholder.style.width = rect.width ? `${rect.width}px` : "100%";
      placeholder.style.height = rect.height ? `${rect.height}px` : "150px";
      placeholder.style.background = "#f3f4f6";
      placeholder.style.border = "1px dashed #d1d5db";
      placeholder.style.display = "flex";
      placeholder.style.alignItems = "center";
      placeholder.style.justifyContent = "center";
      placeholder.style.color = "#9ca3af";
      placeholder.style.fontSize = "12px";
      placeholder.textContent = "External Content (Snapshot Unsupported)";
      el.replaceWith(placeholder);
    });

    container.appendChild(stage);
    document.body.appendChild(container);

    await loadStyleOnce("sidepanel/theme.css").catch(() => {});
    if (data.html.includes("class=")) {
      window.tailwind = window.tailwind || {};
      window.tailwind.config = window.tailwind.config || { darkMode: "class" };
      await loadScriptOnce("sidepanel/vendor/tailwindcss.js");
    }
    await loadScriptOnce("sidepanel/vendor/html2canvas.min.js", "html2canvas");

    if (document.fonts && document.fonts.ready) {
      await Promise.race([document.fonts.ready, new Promise((resolve) => setTimeout(resolve, 250))]);
    }

    await waitForPaint(2);
    await new Promise((resolve) => setTimeout(resolve, 120));
    console.info("[Prism] Capture size enforced", { width, height });

    if (typeof window.html2canvas !== "function") {
      throw new Error("html2canvas not available in parent.");
    }

    const canvas = await window.html2canvas(stage, {
      useCORS: true,
      allowTaint: false,
      backgroundColor: data.background || "#ffffff",
      scale: window.devicePixelRatio || 2,
      logging: false,
      width,
      height,
      windowWidth: width,
      windowHeight: height,
      scrollX: 0,
      scrollY: 0
    });

    const dataUrl = canvas.toDataURL("image/png");
    if (action === "clipboard") {
      await copyImageToClipboard(dataUrl);
      console.info("[Prism] Snapshot copied to clipboard.");
      return;
    }
    const blob = dataUrlToBlob(dataUrl);
    const url = URL.createObjectURL(blob);
    chrome.downloads.download({ url, filename: "prism-snapshot.png", saveAs: true }, () => {
      URL.revokeObjectURL(url);
    });
    console.info("[Prism] Snapshot download triggered.");
  } catch (err) {
    console.error("[Prism] Parent capture failed:", err);
  } finally {
    if (container) {
      container.remove();
    }
  }
}

function normalizeSource(url) {
  if (!url) return "";
  try {
    return new URL(url).host;
  } catch (err) {
    return url;
  }
}

function detectKind(code) {
  if (/from\s+['"]react['"]|ReactDOM|useState\(|className=/i.test(code)) return "react";
  if (/from\s+['"]vue['"]|createApp\s*\(|new\s+Vue\s*\(/i.test(code)) return "vue";
  if (/<[a-z][\s\S]*>/i.test(code)) return "html";
  return "text";
}

function postToSandbox(payload) {
  if (!viewerReady) {
    pendingPayload = payload;
    return;
  }
  viewer.contentWindow.postMessage({ type: "RENDER", ...payload }, "*");
}

function updateViewer(code, language, url, theme) {
  if (!code) {
    postToSandbox({ code: "", language: "text", url: "" });
    return;
  }
  const kind = language && language !== "text" ? language : detectKind(code);
  const source = normalizeSource(url);
  latestPayload = { code, language: kind, url: source, theme: theme || "light" };
  postToSandbox(latestPayload);
}

function notifyPanelStatus(open) {
  if (currentTabId === null || currentTabId === undefined) return;
  chrome.runtime.sendMessage({ type: "PRISM_PANEL_STATUS", tabId: currentTabId, open });
}

function requestLatest() {
  if (targetTabId) {
    const parsedId = Number(targetTabId);
    currentTabId = Number.isFinite(parsedId) ? parsedId : targetTabId;
    notifyPanelStatus(true);
    chrome.runtime.sendMessage({ type: "PRISM_GET_LATEST", tabId: currentTabId }, (resp) => {
      if (resp?.payload) {
        updateViewer(resp.payload.code, resp.payload.language, resp.payload.url, resp.payload.theme);
      }
    });
    return;
  }
  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
    const tabId = tabs?.[0]?.id;
    currentTabId = tabId ?? null;
    notifyPanelStatus(true);
    chrome.runtime.sendMessage({ type: "PRISM_GET_LATEST", tabId }, (resp) => {
      if (resp?.payload) {
        updateViewer(resp.payload.code, resp.payload.language, resp.payload.url, resp.payload.theme);
      }
    });
  });
}

chrome.runtime.onMessage.addListener((message) => {
  if (targetTabId && message?.tabId && String(message.tabId) !== String(targetTabId)) {
    return;
  }
  if (message?.type === "PRISM_RENDER") {
    currentTabId = message.tabId ?? currentTabId;
    notifyPanelStatus(true);
    updateViewer(message.code, message.language, message.url, message.theme);
  }
});

if (openWindowBtn) {
  openWindowBtn.addEventListener("click", () => {
    const tabId = currentTabId ?? null;
    const url = chrome.runtime.getURL(`sidepanel/window.html${tabId ? `?tabId=${encodeURIComponent(tabId)}` : ""}`);
    chrome.windows.create({ url, type: "popup", width: 1200, height: 900 });
  });
}

if (snapshotBtn) {
  snapshotBtn.addEventListener("click", () => {
    if (!viewerReady) return;
    pendingSnapshotAction = "download";
    viewer.contentWindow.postMessage({ type: "PRISM_SNAPSHOT" }, "*");
  });
}

if (copyBtn) {
  copyBtn.addEventListener("click", () => {
    if (!viewerReady) return;
    pendingSnapshotAction = "clipboard";
    viewer.contentWindow.postMessage({ type: "PRISM_SNAPSHOT" }, "*");
  });
}

if (saveHtmlBtn) {
  saveHtmlBtn.addEventListener("click", () => {
    if (!latestPayload?.code) return;
    const blob = new Blob([latestPayload.code], { type: "text/html;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    chrome.downloads.download(
      {
        url,
        filename: "prism-export.html",
        saveAs: true,
      },
      () => URL.revokeObjectURL(url)
    );
  });
}

function dataUrlToBlob(dataUrl) {
  const [header, data] = dataUrl.split(",");
  const mime = header.match(/:(.*?);/)[1] || "image/png";
  const binary = atob(data);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i += 1) {
    bytes[i] = binary.charCodeAt(i);
  }
  return new Blob([bytes], { type: mime });
}

async function copyImageToClipboard(dataUrl) {
  if (!navigator.clipboard || !window.ClipboardItem) {
    console.warn("[Prism] Clipboard API not available.");
    return;
  }
  const blob = dataUrlToBlob(dataUrl);
  await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
}

window.addEventListener("message", (event) => {
  if (event.source !== viewer.contentWindow) return;
  const data = event.data || {};

  // 1. 샌드박스로부터 캡처용 데이터를 받았을 때 실행
  if (data.type === "PRISM_EXPORT_FOR_CAPTURE") {
    performCaptureInParent(data);
    return;
  }

  const { type, dataUrl, error, stage, meta } = data;

  if (type === "PRISM_SNAPSHOT_RESULT" && dataUrl) {
    const action = pendingSnapshotAction || "download";
    pendingSnapshotAction = null;
    if (action === "clipboard") {
      copyImageToClipboard(dataUrl).catch((err) => console.warn("[Prism] Clipboard copy failed:", err));
    } else {
      const blob = dataUrlToBlob(dataUrl);
      const url = URL.createObjectURL(blob);
      chrome.downloads.download({ url, filename: "prism-snapshot.png", saveAs: true }, () => URL.revokeObjectURL(url));
    }
  }

  if (type === "PRISM_SNAPSHOT_RESULT" && error) {
    console.warn("[Prism] Snapshot failed:", stage ? `(${stage})` : "", error, meta || "");
    pendingSnapshotAction = null;
  }

  if (type === "PRISM_SNAPSHOT_STATUS") {
    console.info("[Prism] Snapshot status:", stage || "unknown");
  }
});

viewer.addEventListener("load", () => {
  viewerReady = true;
  if (pendingPayload) {
    postToSandbox(pendingPayload);
    pendingPayload = null;
  }
});

window.addEventListener("beforeunload", () => {
  notifyPanelStatus(false);
});

requestLatest();
